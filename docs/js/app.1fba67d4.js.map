{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/Mywork/index.vue?4976","webpack:///./src/App.vue?39c0","webpack:///./src/components/Mywork/index.vue?78e5","webpack:///./src/components/Mywork/js/glsl/shape.vert","webpack:///./src/components/Mywork/js/glsl/shape.frag","webpack:///./src/components/Mywork/js/minMatrix/minMatrix.js","webpack:///./src/components/Mywork/js/Common.js","webpack:///./src/components/Mywork/js/MyGL.js","webpack:///src/components/Mywork/index.vue","webpack:///./src/components/Mywork/index.vue?caeb","webpack:///./src/components/Mywork/index.vue?9f49","webpack:///src/App.vue","webpack:///./src/App.vue?1160","webpack:///./src/App.vue","webpack:///./src/main.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","_vm","this","_h","$createElement","_c","_self","attrs","staticRenderFns","ref","Mat4","Float32Array","source","out","target","Error","mat0","mat1","a","b","e","f","g","h","k","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","mat","vec","angle","axis","sq","Math","sqrt","sin","cos","q","u","v","w","x","y","z","eye","center","up","eyeX","eyeY","eyeZ","centerX","centerY","centerZ","upX","upY","upZ","identity","x0","x1","x2","y0","y1","y2","z0","z1","z2","fovy","aspect","near","far","tan","PI","left","right","top","bottom","ivd","position","centerPoint","upDirection","vmat","pmat","vpmat","lookAt","perspective","multiply","view","projection","viewProjection","width","height","halfWidth","halfHeight","toVecIV","NaN","translation","qtn","scale","xx","xy","xz","yy","yz","zz","wx","wy","wz","sx","sy","sz","Common","gl","v_shader","f_shader","prg","attLocation","Array","position_vbo","color_vbo","normal_vbo","mMatrix","vMatrix","pMatrix","tmpMatrix","mvpMatrix","uniLocation","ibo","size","windowW","windowH","attStride","vertex_position","vertex_color","index","count","torusData","normal","lightDirection","eyeDirection","ambientCoor","$canvas","setSize","getContext","createShader","createProgram","getAttribLocation","torus","color","createVBO","setAttribute","createIBO","bindBuffer","ELEMENT_ARRAY_BUFFER","getUniformLocation","invMatrix","enable","DEPTH_TEST","depthFunc","LEQUAL","CULL_FACE","update","alert","innerWidth","innerHeight","shader","shader_text","VERTEX_SHADER","vertexShader","FRAGMENT_SHADER","fragmentShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","getProgramIngoLog","vbo","createBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","vboArray","attL","attS","enableVertexAttribArray","vertexAttribPointer","FLOAT","requestAnimationFrame","clearColor","clearDepth","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","rad","rotate","inverse","uniformMatrix4fv","uniform3fv","uniform4fv","drawElements","TRIANGLES","UNSIGNED_SHORT","flush","_ibo","Int16Array","row","column","irad","orad","pos","nor","col","idx","rr","ry","ii","tr","tx","ty","tz","rx","rz","tc","hsva","jj","th","floor","MyGL","props","init","mounted","$refs","canvas","methods","component","components","Vue","config","productionTip","render","App","$mount"],"mappings":"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","file":"js/app.1fba67d4.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=style&index=0&lang=css&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('MyGL')],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"webgl\"}},[_c('canvas',{ref:\"canvas\",attrs:{\"id\":\"webgl_canvas\"}})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export default \"attribute vec3 position;\\r\\nattribute vec3 normal;\\r\\nattribute vec4 color;\\r\\nuniform   mat4 mvpMatrix;\\r\\nvarying   vec3 vNormal;\\r\\nvarying   vec4 vColor;\\r\\n\\r\\nvoid main(void){\\r\\n    vNormal     = normal;\\r\\n    vColor      = color;\\r\\n    gl_Position = mvpMatrix * vec4(position, 1.0);\\r\\n}\";","export default \"precision mediump float;\\r\\n\\r\\nuniform mat4 invMatrix;\\r\\nuniform vec3 lightDirection;\\r\\nuniform vec3 eyeDirection;\\r\\nuniform vec4 ambientColor;\\r\\nvarying vec3 vNormal;\\r\\nvarying vec4 vColor;\\r\\n\\r\\nvoid main(void){\\r\\n    vec3 invLight  = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\\r\\n    vec3 invEye    = normalize(invMatrix * vec4(eyeDirection, 0.0)).xyz;\\r\\n    vec3 halfLE    = normalize(invLight + invEye);\\r\\n    float diffuse  = clamp(dot(vNormal, invLight), 0.0, 1.0);\\r\\n    float specular = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0);\\r\\n    vec4 destColor = vColor * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;\\r\\n    gl_FragColor = destColor;\\r\\n}\";","/**\n * Mat4\n * @class Mat4\n */\nexport class Mat4 {\n    /**\n     * 4x4 の正方行列を生成する\n     * @return {Float32Array} 行列格納用の配列\n     */\n    create(){\n        return new Float32Array(16);\n    }\n    /**\n     * 単位行列を返す（引数が与えられた場合はそれを初期化する）\n     * @param {Mat4} [source] - 単位化する行列\n     * @return {Mat4} 単位化した行列\n     */\n    identity(source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        out[0]  = 1; out[1]  = 0; out[2]  = 0; out[3]  = 0;\n        out[4]  = 0; out[5]  = 1; out[6]  = 0; out[7]  = 0;\n        out[8]  = 0; out[9]  = 0; out[10] = 1; out[11] = 0;\n        out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;\n        return out;\n    }\n    /**\n     * 行列の値をコピーして返す（第二引数が与えられた場合その行列がコピー先となる）\n     * @param {Mat4} target - コピー元の行列\n     * @param {Mat4} [source] - コピー先の行列\n     * @return {Mat4} コピー先の行列\n     */\n    copy(target, source){\n        let out = source;\n        if(target == null){\n            throw new Error('Mat4.copy: invalid argument');\n        }\n        if(out == null){out = Mat4.create();}\n        out[0]  = target[0];  out[1]  = target[1];  out[2]  = target[2];  out[3]  = target[3];\n        out[4]  = target[4];  out[5]  = target[5];  out[6]  = target[6];  out[7]  = target[7];\n        out[8]  = target[8];  out[9]  = target[9];  out[10] = target[10]; out[11] = target[11];\n        out[12] = target[12]; out[13] = target[13]; out[14] = target[14]; out[15] = target[15];\n        return out;\n    }\n    /**\n     * 行列を乗算して返す（第三引数が与えられた場合その行列に結果を代入する）\n     * @param {Mat4} mat0 - 乗算される行列\n     * @param {Mat4} mat1 - 乗算する行列\n     * @param {Mat4} [source] - 乗算結果を格納する行列\n     * @return {Mat4} 乗算結果の行列\n     */\n    multiply(mat0, mat1, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        let a = mat0[0],  b = mat0[1],  c = mat0[2],  d = mat0[3],\n            e = mat0[4],  f = mat0[5],  g = mat0[6],  h = mat0[7],\n            i = mat0[8],  j = mat0[9],  k = mat0[10], l = mat0[11],\n            m = mat0[12], n = mat0[13], o = mat0[14], p = mat0[15],\n            A = mat1[0],  B = mat1[1],  C = mat1[2],  D = mat1[3],\n            E = mat1[4],  F = mat1[5],  G = mat1[6],  H = mat1[7],\n            I = mat1[8],  J = mat1[9],  K = mat1[10], L = mat1[11],\n            M = mat1[12], N = mat1[13], O = mat1[14], P = mat1[15];\n        out[0]  = A * a + B * e + C * i + D * m;\n        out[1]  = A * b + B * f + C * j + D * n;\n        out[2]  = A * c + B * g + C * k + D * o;\n        out[3]  = A * d + B * h + C * l + D * p;\n        out[4]  = E * a + F * e + G * i + H * m;\n        out[5]  = E * b + F * f + G * j + H * n;\n        out[6]  = E * c + F * g + G * k + H * o;\n        out[7]  = E * d + F * h + G * l + H * p;\n        out[8]  = I * a + J * e + K * i + L * m;\n        out[9]  = I * b + J * f + K * j + L * n;\n        out[10] = I * c + J * g + K * k + L * o;\n        out[11] = I * d + J * h + K * l + L * p;\n        out[12] = M * a + N * e + O * i + P * m;\n        out[13] = M * b + N * f + O * j + P * n;\n        out[14] = M * c + N * g + O * k + P * o;\n        out[15] = M * d + N * h + O * l + P * p;\n        return out;\n    }\n    /**\n     * 行列に拡大縮小を適用する（第三引数が与えられた場合その行列に結果を代入する）\n     * @param {Mat4} mat - 適用を受ける行列\n     * @param {Vec3} vec - XYZ の各軸に対して拡縮を適用する値のベクトル\n     * @param {Mat4} [source] - 結果を格納する行列\n     * @return {Mat4} 結果の行列\n     */\n    scale(mat, vec, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        out[0]  = mat[0]  * vec[0];\n        out[1]  = mat[1]  * vec[0];\n        out[2]  = mat[2]  * vec[0];\n        out[3]  = mat[3]  * vec[0];\n        out[4]  = mat[4]  * vec[1];\n        out[5]  = mat[5]  * vec[1];\n        out[6]  = mat[6]  * vec[1];\n        out[7]  = mat[7]  * vec[1];\n        out[8]  = mat[8]  * vec[2];\n        out[9]  = mat[9]  * vec[2];\n        out[10] = mat[10] * vec[2];\n        out[11] = mat[11] * vec[2];\n        out[12] = mat[12];\n        out[13] = mat[13];\n        out[14] = mat[14];\n        out[15] = mat[15];\n        return out;\n    }\n    /**\n     * 行列に平行移動を適用する（第三引数が与えられた場合その行列に結果を代入する）\n     * @param {Mat4} mat - 適用を受ける行列\n     * @param {Vec3} vec - XYZ の各軸に対して平行移動を適用する値の行列\n     * @param {Mat4} [source] - 結果を格納する行列\n     * @return {Mat4} 結果の行列\n     */\n    translate(mat, vec, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        out[0] = mat[0]; out[1] = mat[1]; out[2]  = mat[2];  out[3]  = mat[3];\n        out[4] = mat[4]; out[5] = mat[5]; out[6]  = mat[6];  out[7]  = mat[7];\n        out[8] = mat[8]; out[9] = mat[9]; out[10] = mat[10]; out[11] = mat[11];\n        out[12] = mat[0] * vec[0] + mat[4] * vec[1] + mat[8]  * vec[2] + mat[12];\n        out[13] = mat[1] * vec[0] + mat[5] * vec[1] + mat[9]  * vec[2] + mat[13];\n        out[14] = mat[2] * vec[0] + mat[6] * vec[1] + mat[10] * vec[2] + mat[14];\n        out[15] = mat[3] * vec[0] + mat[7] * vec[1] + mat[11] * vec[2] + mat[15];\n        return out;\n    }\n    /**\n     * 行列に回転を適用する（第四引数が与えられた場合その行列に結果を代入する）\n     * @param {Mat4} mat - 適用を受ける行列\n     * @param {number} angle - 回転量を表す値（ラジアン）\n     * @param {Vec3} axis - 回転の軸\n     * @param {Mat4} [source] - 結果を格納する行列\n     * @return {Mat4} 結果の行列\n     */\n    rotate(mat, angle, axis, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        let sq = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n        if(!sq){return null;}\n        let a = axis[0], b = axis[1], c = axis[2];\n        if(sq != 1){sq = 1 / sq; a *= sq; b *= sq; c *= sq;}\n        let d = Math.sin(angle), e = Math.cos(angle), f = 1 - e,\n            g = mat[0],  h = mat[1], i = mat[2],  j = mat[3],\n            k = mat[4],  l = mat[5], m = mat[6],  n = mat[7],\n            o = mat[8],  p = mat[9], q = mat[10], r = mat[11],\n            s = a * a * f + e,\n            t = b * a * f + c * d,\n            u = c * a * f - b * d,\n            v = a * b * f - c * d,\n            w = b * b * f + e,\n            x = c * b * f + a * d,\n            y = a * c * f + b * d,\n            z = b * c * f - a * d,\n            A = c * c * f + e;\n        if(angle){\n            if(mat != out){\n                out[12] = mat[12]; out[13] = mat[13];\n                out[14] = mat[14]; out[15] = mat[15];\n            }\n        }else{\n            out = mat;\n        }\n        out[0]  = g * s + k * t + o * u;\n        out[1]  = h * s + l * t + p * u;\n        out[2]  = i * s + m * t + q * u;\n        out[3]  = j * s + n * t + r * u;\n        out[4]  = g * v + k * w + o * x;\n        out[5]  = h * v + l * w + p * x;\n        out[6]  = i * v + m * w + q * x;\n        out[7]  = j * v + n * w + r * x;\n        out[8]  = g * y + k * z + o * A;\n        out[9]  = h * y + l * z + p * A;\n        out[10] = i * y + m * z + q * A;\n        out[11] = j * y + n * z + r * A;\n        return out;\n    }\n    /**\n     * ビュー座標変換行列を生成する（第四引数が与えられた場合その行列に結果を代入する）\n     * @param {Vec3} eye - 視点位置\n     * @param {Vec3} center - 注視点\n     * @param {Vec3} up - 上方向を示すベクトル\n     * @param {Mat4} [source] - 結果を格納する行列\n     * @return {Mat4} 結果の行列\n     */\n    lookAt(eye, center, up, source){\n        let eyeX    = eye[0],    eyeY    = eye[1],    eyeZ    = eye[2],\n            centerX = center[0], centerY = center[1], centerZ = center[2],\n            upX     = up[0],     upY     = up[1],     upZ     = up[2];\n        if(eyeX == centerX && eyeY == centerY && eyeZ == centerZ){return Mat4.identity(source);}\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        let x0, x1, x2, y0, y1, y2, z0, z1, z2, l;\n        z0 = eyeX - center[0]; z1 = eyeY - center[1]; z2 = eyeZ - center[2];\n        l = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= l; z1 *= l; z2 *= l;\n        x0 = upY * z2 - upZ * z1;\n        x1 = upZ * z0 - upX * z2;\n        x2 = upX * z1 - upY * z0;\n        l = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if(!l){\n            x0 = 0; x1 = 0; x2 = 0;\n        }else{\n            l = 1 / l;\n            x0 *= l; x1 *= l; x2 *= l;\n        }\n        y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;\n        l = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if(!l){\n            y0 = 0; y1 = 0; y2 = 0;\n        }else{\n            l = 1 / l;\n            y0 *= l; y1 *= l; y2 *= l;\n        }\n        out[0] = x0; out[1] = y0; out[2]  = z0; out[3]  = 0;\n        out[4] = x1; out[5] = y1; out[6]  = z1; out[7]  = 0;\n        out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;\n        out[12] = -(x0 * eyeX + x1 * eyeY + x2 * eyeZ);\n        out[13] = -(y0 * eyeX + y1 * eyeY + y2 * eyeZ);\n        out[14] = -(z0 * eyeX + z1 * eyeY + z2 * eyeZ);\n        out[15] = 1;\n        return out;\n    }\n    /**\n     * 透視投影変換行列を生成する（第五引数が与えられた場合その行列に結果を代入する）\n     * @param {number} fovy - 視野角（度数法）\n     * @param {number} aspect - アスペクト比（幅 / 高さ）\n     * @param {number} near - ニアクリップ面までの距離\n     * @param {number} far - ファークリップ面までの距離\n     * @param {Mat4} [source] - 結果を格納する行列\n     * @return {Mat4} 結果の行列\n     */\n    perspective(fovy, aspect, near, far, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        let t = near * Math.tan(fovy * Math.PI / 360);\n        let r = t * aspect;\n        let a = r * 2, b = t * 2, c = far - near;\n        out[0]  = near * 2 / a;\n        out[1]  = 0;\n        out[2]  = 0;\n        out[3]  = 0;\n        out[4]  = 0;\n        out[5]  = near * 2 / b;\n        out[6]  = 0;\n        out[7]  = 0;\n        out[8]  = 0;\n        out[9]  = 0;\n        out[10] = -(far + near) / c;\n        out[11] = -1;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = -(far * near * 2) / c;\n        out[15] = 0;\n        return out;\n    }\n    /**\n     * 正射影投影変換行列を生成する（第七引数が与えられた場合その行列に結果を代入する）\n     * @param {number} left - 左端\n     * @param {number} right - 右端\n     * @param {number} top - 上端\n     * @param {number} bottom - 下端\n     * @param {number} near - ニアクリップ面までの距離\n     * @param {number} far - ファークリップ面までの距離\n     * @param {Mat4} [source] - 結果を格納する行列\n     * @return {Mat4} 結果の行列\n     */\n    ortho(left, right, top, bottom, near, far, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        let h = (right - left);\n        let v = (top - bottom);\n        let d = (far - near);\n        out[0]  = 2 / h;\n        out[1]  = 0;\n        out[2]  = 0;\n        out[3]  = 0;\n        out[4]  = 0;\n        out[5]  = 2 / v;\n        out[6]  = 0;\n        out[7]  = 0;\n        out[8]  = 0;\n        out[9]  = 0;\n        out[10] = -2 / d;\n        out[11] = 0;\n        out[12] = -(left + right) / h;\n        out[13] = -(top + bottom) / v;\n        out[14] = -(far + near) / d;\n        out[15] = 1;\n        return out;\n    }\n    /**\n     * 転置行列を生成する（第二引数が与えられた場合その行列に結果を代入する）\n     * @param {Mat4} mat - 適用する行列\n     * @param {Mat4} [source] - 結果を格納する行列\n     * @return {Mat4} 結果の行列\n     */\n    transpose(mat, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        out[0]  = mat[0];  out[1]  = mat[4];\n        out[2]  = mat[8];  out[3]  = mat[12];\n        out[4]  = mat[1];  out[5]  = mat[5];\n        out[6]  = mat[9];  out[7]  = mat[13];\n        out[8]  = mat[2];  out[9]  = mat[6];\n        out[10] = mat[10]; out[11] = mat[14];\n        out[12] = mat[3];  out[13] = mat[7];\n        out[14] = mat[11]; out[15] = mat[15];\n        return out;\n    }\n    /**\n     * 逆行列を生成する（第二引数が与えられた場合その行列に結果を代入する）\n     * @param {Mat4} mat - 適用する行列\n     * @param {Mat4} [source] - 結果を格納する行列\n     * @return {Mat4} 結果の行列\n     */\n    inverse(mat, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        let a = mat[0],  b = mat[1],  c = mat[2],  d = mat[3],\n            e = mat[4],  f = mat[5],  g = mat[6],  h = mat[7],\n            i = mat[8],  j = mat[9],  k = mat[10], l = mat[11],\n            m = mat[12], n = mat[13], o = mat[14], p = mat[15],\n            q = a * f - b * e, r = a * g - c * e,\n            s = a * h - d * e, t = b * g - c * f,\n            u = b * h - d * f, v = c * h - d * g,\n            w = i * n - j * m, x = i * o - k * m,\n            y = i * p - l * m, z = j * o - k * n,\n            A = j * p - l * n, B = k * p - l * o,\n            ivd = 1 / (q * B - r * A + s * z + t * y - u * x + v * w);\n        out[0]  = ( f * B - g * A + h * z) * ivd;\n        out[1]  = (-b * B + c * A - d * z) * ivd;\n        out[2]  = ( n * v - o * u + p * t) * ivd;\n        out[3]  = (-j * v + k * u - l * t) * ivd;\n        out[4]  = (-e * B + g * y - h * x) * ivd;\n        out[5]  = ( a * B - c * y + d * x) * ivd;\n        out[6]  = (-m * v + o * s - p * r) * ivd;\n        out[7]  = ( i * v - k * s + l * r) * ivd;\n        out[8]  = ( e * A - f * y + h * w) * ivd;\n        out[9]  = (-a * A + b * y - d * w) * ivd;\n        out[10] = ( m * u - n * s + p * q) * ivd;\n        out[11] = (-i * u + j * s - l * q) * ivd;\n        out[12] = (-e * z + f * x - g * w) * ivd;\n        out[13] = ( a * z - b * x + c * w) * ivd;\n        out[14] = (-m * t + n * r - o * q) * ivd;\n        out[15] = ( i * t - j * r + k * q) * ivd;\n        return out;\n    }\n    /**\n     * 行列にベクトルを乗算する（ベクトルに行列を適用する）\n     * @param {Mat4} mat - 適用する行列\n     * @param {Vec3} vec - 乗算するベクトル（３つの要素を持つ配列）\n     * @return {Float32Array} 結果のベクトル\n     */\n    toVecIII(mat, vec){\n        let a = mat[0],  b = mat[1],  c = mat[2],\n            e = mat[4],  f = mat[5],  g = mat[6],\n            i = mat[8],  j = mat[9],  k = mat[10],\n            m = mat[12], n = mat[13], o = mat[14];\n        let x = vec[0], y = vec[1], z = vec[2];\n        let out = [];\n        out[0] = x * a + y * e + z * i + m;\n        out[1] = x * b + y * f + z * j + n;\n        out[2] = x * c + y * g + z * k + o;\n        vec = out;\n        return out;\n    }\n    /**\n     * 行列にベクトルを乗算する（ベクトルに行列を適用する）\n     * @param {Mat4} mat - 適用する行列\n     * @param {Array.<number>} vec - 乗算するベクトル（４つの要素を持つ配列）\n     * @return {Float32Array} 結果のベクトル\n     */\n    toVecIV(mat, vec){\n        let a = mat[0],  b = mat[1],  c = mat[2],  d = mat[3],\n            e = mat[4],  f = mat[5],  g = mat[6],  h = mat[7],\n            i = mat[8],  j = mat[9],  k = mat[10], l = mat[11],\n            m = mat[12], n = mat[13], o = mat[14], p = mat[15];\n        let x = vec[0], y = vec[1], z = vec[2], w = vec[3];\n        let out = [];\n        out[0] = x * a + y * e + z * i + w * m;\n        out[1] = x * b + y * f + z * j + w * n;\n        out[2] = x * c + y * g + z * k + w * o;\n        out[3] = x * d + y * h + z * l + w * p;\n        vec = out;\n        return out;\n    }\n    /**\n     * カメラのプロパティに相当する情報を受け取り行列を生成する\n     * @param {Vec3} position - カメラの座標\n     * @param {Vec3} centerPoint - カメラの注視点\n     * @param {Vec3} upDirection - カメラの上方向\n     * @param {number} fovy - 視野角\n     * @param {number} aspect - アスペクト比\n     * @param {number} near - ニアクリップ面\n     * @param {number} far - ファークリップ面\n     * @param {Mat4} vmat - ビュー座標変換行列の結果を格納する行列\n     * @param {Mat4} pmat - 透視投影座標変換行列の結果を格納する行列\n     * @param {Mat4} vpmat - ビュー x 透視投影変換行列の結果を格納する行列\n     */\n    vpFromCameraProperty(position, centerPoint, upDirection, fovy, aspect, near, far, vmat, pmat, vpmat){\n        Mat4.lookAt(position, centerPoint, upDirection, vmat);\n        Mat4.perspective(fovy, aspect, near, far, pmat);\n        Mat4.multiply(pmat, vmat, vpmat);\n        return {\n            view: vmat,\n            projection: pmat,\n            viewProjection: vpmat,\n        };\n    }\n    /**\n     * MVP 行列に相当する行列を受け取りベクトルを変換して返す\n     * @param {Mat4} mat - MVP 行列\n     * @param {Array.<number>} vec - MVP 行列と乗算する３つの要素を持つベクトル\n     * @param {number} width - ビューポートの幅\n     * @param {number} height - ビューポートの高さ\n     * @return {Array.<number>} 結果のベクトル（２つの要素を持つベクトル）\n     */\n    screenPositionFromMvp(mat, vec, width, height){\n        let halfWidth = width * 0.5;\n        let halfHeight = height * 0.5;\n        let v = Mat4.toVecIV(mat, [vec[0], vec[1], vec[2], 1.0]);\n        if(v[3] <= 0.0){return [NaN, NaN];}\n        v[0] /= v[3]; v[1] /= v[3]; v[2] /= v[3];\n        return [\n            halfWidth + v[0] * halfWidth,\n            halfHeight - v[1] * halfHeight\n        ];\n    }\n    /**\n     * 平行移動ベクトル、回転クォータニオン、拡大縮小ベクトルから行列を生成する\n     * @param {Vec3} translation - 平行移動ベクトル\n     * @param {Qtn} qtn - 回転を表すクォータニオン\n     * @param {Vec3} scale - 拡大縮小ベクトル\n     * @param {Mat4} [source] - 結果を格納する行列\n     * @return {Mat4} 結果の行列\n     */\n    compose(translation, qtn, scale, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        let x = qtn[0], y = qtn[1], z = qtn[2], w = qtn[3];\n        let x2 = x + x,  y2 = y + y,  z2 = z + z;\n        let xx = x * x2, xy = x * y2, xz = x * z2;\n        let yy = y * y2, yz = y * z2, zz = z * z2;\n        let wx = w * x2, wy = w * y2, wz = w * z2;\n        let sx = scale[0], sy = scale[1], sz = scale[2];\n\n        out[0]  = (1 - (yy + zz)) * sx;\n        out[1]  = (xy + wz) * sx;\n        out[2]  = (xz - wy) * sx;\n        out[3]  = 0;\n        out[4]  = (xy - wz) * sy;\n        out[5]  = (1 - (xx + zz)) * sy;\n        out[6]  = (yz + wx) * sy;\n        out[7]  = 0;\n        out[8]  = (xz + wy) * sz;\n        out[9]  = (yz - wx) * sz;\n        out[10] = (1 - (xx + yy)) * sz;\n        out[11] = 0;\n        out[12] = translation[0];\n        out[13] = translation[1];\n        out[14] = translation[2];\n        out[15] = 1;\n        return out;\n    }\n}\n\n/**\n * Vec3\n * @class Vec3\n */\nexport class Vec3 {\n    /**\n     * ３つの要素を持つベクトルを生成する\n     * @return {Float32Array} ベクトル格納用の配列\n     */\n    static create(){\n        return new Float32Array(3);\n    }\n    /**\n     * 符号を反転する\n     * @param {Vec3} v - ３つの要素を持つベクトル\n     * @return {Vec3} 符号を反転したベクトル\n     */\n    static negate(v){\n        let out = Vec3.create();\n        out[0] = -v[0];\n        out[1] = -v[1];\n        out[2] = -v[2];\n        return out;\n    }\n    /**\n     * ベクトルの値をコピーして返す（第二引数が与えられた場合そのベクトルがコピー先となる）\n     * @param {Vec3} target - コピー元のベクトル\n     * @param {Vec3} [source] - コピー先のベクトル\n     * @return {Vec3} コピー先のベクトル\n     */\n    static copy(target, source){\n        let out = source;\n        if(target == null){\n            throw new Error('Vec3.copy: invalid argument');\n        }\n        if(out == null){out = Vec3.create();}\n        out[0] = target[0];\n        out[1] = target[1];\n        out[2] = target[2];\n        return out;\n    }\n    /**\n     * ベクトルの長さ（大きさ）を返す\n     * @param {Vec3} v - ３つの要素を持つベクトル\n     * @return {number} ベクトルの長さ（大きさ）\n     */\n    static length(v){\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n    }\n    /**\n     * ２つの座標（始点・終点）を結ぶベクトルを返す\n     * @param {Vec3} v0 - ３つの要素を持つ始点座標\n     * @param {Vec3} v1 - ３つの要素を持つ終点座標\n     * @return {Vec3} 視点と終点を結ぶベクトル\n     */\n    static distance(v0, v1){\n        let out = Vec3.create();\n        out[0] = v1[0] - v0[0];\n        out[1] = v1[1] - v0[1];\n        out[2] = v1[2] - v0[2];\n        return out;\n    }\n    /**\n     * ベクトルを正規化した結果を返す\n     * @param {Vec3} v - ３つの要素を持つベクトル\n     * @return {Vec3} 正規化したベクトル\n     */\n    static normalize(v){\n        let out = Vec3.create();\n        let l = Vec3.length(v);\n        if(l > 0){\n            let e = 1.0 / l;\n            out[0] = v[0] * e;\n            out[1] = v[1] * e;\n            out[2] = v[2] * e;\n        }else{\n            out[0] = 0.0;\n            out[1] = 0.0;\n            out[2] = 0.0;\n        }\n        return out;\n    }\n    /**\n     * ２つのベクトルを加算した結果を返す\n     * @param {Vec3} v0 - ３つの要素を持つベクトル\n     * @param {Vec3} v1 - ３つの要素を持つベクトル\n     * @return {number} 加算した結果\n     */\n    static add(v0, v1){\n        let out = Vec3.create();\n        out[0] = v0[0] + v1[0];\n        out[1] = v0[1] + v1[1];\n        out[2] = v0[2] + v1[2];\n        return out;\n    }\n    /**\n     * ２つのベクトルを減算した結果を返す\n     * @param {Vec3} v0 - ３つの要素を持つベクトル\n     * @param {Vec3} v1 - ３つの要素を持つベクトル\n     * @return {number} 減算した結果\n     */\n    static sub(v0, v1){\n        let out = Vec3.create();\n        out[0] = v0[0] - v1[0];\n        out[1] = v0[1] - v1[1];\n        out[2] = v0[2] - v1[2];\n        return out;\n    }\n    /**\n     * ２つのベクトルの要素同士を乗算した結果を返す\n     * @param {Vec3} v0 - ３つの要素を持つベクトル\n     * @param {Vec3} v1 - ３つの要素を持つベクトル\n     * @return {number} 乗算した結果\n     */\n    static multiply(v0, v1){\n        let out = Vec3.create();\n        out[0] = v0[0] * v1[0];\n        out[1] = v0[1] * v1[1];\n        out[2] = v0[2] * v1[2];\n        return out;\n    }\n    /**\n     * ２つのベクトルの要素同士を除算した結果を返す\n     * @param {Vec3} v0 - ３つの要素を持つベクトル\n     * @param {Vec3} v1 - ３つの要素を持つベクトル\n     * @return {number} 除算した結果\n     */\n    static divide(v0, v1){\n        let out = Vec3.create();\n        out[0] = v0[0] / v1[0];\n        out[1] = v0[1] / v1[1];\n        out[2] = v0[2] / v1[2];\n        return out;\n    }\n    /**\n     * ２つのベクトルの内積の結果を返す\n     * @param {Vec3} v0 - ３つの要素を持つベクトル\n     * @param {Vec3} v1 - ３つの要素を持つベクトル\n     * @return {number} 内積の結果\n     */\n    static dot(v0, v1){\n        return v0[0] * v1[0] + v0[1] * v1[1] + v0[2] * v1[2];\n    }\n    /**\n     * ２つのベクトルの外積の結果を返す\n     * @param {Vec3} v0 - ３つの要素を持つベクトル\n     * @param {Vec3} v1 - ３つの要素を持つベクトル\n     * @return {Vec3} 外積の結果\n     */\n    static cross(v0, v1){\n        let out = Vec3.create();\n        out[0] = v0[1] * v1[2] - v0[2] * v1[1];\n        out[1] = v0[2] * v1[0] - v0[0] * v1[2];\n        out[2] = v0[0] * v1[1] - v0[1] * v1[0];\n        return out;\n    }\n    /**\n     * ２つのベクトル間を補間した結果を返す\n     * @param {Vec3} v0 - ３つの要素を持つベクトル\n     * @param {Vec3} v1 - ３つの要素を持つベクトル\n     * @param {number} t - 補間係数\n     * @return {Vec3} 補間の結果\n     */\n    static lerp(v0, v1, t){\n        const time = Math.min(Math.max(t, 0.0), 1.0);\n        if(time === 0.0){return Vec3.copy(v0);}\n        if(time === 1.0){return Vec3.copy(v1);}\n        let out = Vec3.sub(v1, v0);\n        out[0] = v0[0] + out[0] * time;\n        out[1] = v0[1] + out[1] * time;\n        out[2] = v0[2] + out[2] * time;\n        return out;\n    }\n    /**\n     * ３つの座標から面法線を求めて返す\n     * @param {Vec3} v0 - ３つの要素を持つ座標\n     * @param {Vec3} v1 - ３つの要素を持つ座標\n     * @param {Vec3} v2 - ３つの要素を持つ座標\n     * @return {Vec3} 面法線ベクトル\n     */\n    static faceNormal(v0, v1, v2){\n        let out = Vec3.create();\n        let vec1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];\n        let vec2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];\n        out[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];\n        out[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];\n        out[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];\n        return Vec3.normalize(out);\n    }\n}\n\n/**\n * Vec2\n * @class Vec2\n */\nexport class Vec2 {\n    /**\n     * ２つの要素を持つベクトルを生成する\n     * @return {Float32Array} ベクトル格納用の配列\n     */\n    static create(){\n        return new Float32Array(2);\n    }\n    /**\n     * 符号を反転する\n     * @param {Vec2} v - ２つの要素を持つベクトル\n     * @return {Vec2} 符号を反転したベクトル\n     */\n    static negate(v){\n        let out = Vec2.create();\n        out[0] = -v[0];\n        out[1] = -v[1];\n        return out;\n    }\n    /**\n     * ベクトルの値をコピーして返す（第二引数が与えられた場合そのベクトルがコピー先となる）\n     * @param {Vec2} target - コピー元のベクトル\n     * @param {Vec2} [source] - コピー先のベクトル\n     * @return {Vec2} コピー先のベクトル\n     */\n    static copy(target, source){\n        let out = source;\n        if(target == null){\n            throw new Error('Vec2.copy: invalid argument');\n        }\n        if(out == null){out = Vec2.create();}\n        out[0] = target[0];\n        out[1] = target[1];\n        return out;\n    }\n    /**\n     * ベクトルの長さ（大きさ）を返す\n     * @param {Vec2} v - ２つの要素を持つベクトル\n     * @return {number} ベクトルの長さ（大きさ）\n     */\n    static length(v){\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    }\n    /**\n     * ２つの座標（始点・終点）を結ぶベクトルを返す\n     * @param {Vec2} v0 - ２つの要素を持つ始点座標\n     * @param {Vec2} v1 - ２つの要素を持つ終点座標\n     * @return {Vec2} 視点と終点を結ぶベクトル\n     */\n    static distance(v0, v1){\n        let out = Vec2.create();\n        out[0] = v1[0] - v0[0];\n        out[1] = v1[1] - v0[1];\n        return out;\n    }\n    /**\n     * ベクトルを正規化した結果を返す\n     * @param {Vec2} v - ２つの要素を持つベクトル\n     * @return {Vec2} 正規化したベクトル\n     */\n    static normalize(v){\n        let out = Vec2.create();\n        let l = Vec2.length(v);\n        if(l > 0){\n            let e = 1.0 / l;\n            out[0] = v[0] * e;\n            out[1] = v[1] * e;\n        }\n        return out;\n    }\n    /**\n     * ２つのベクトルを加算した結果を返す\n     * @param {Vec2} v0 - ２つの要素を持つベクトル\n     * @param {Vec2} v1 - ２つの要素を持つベクトル\n     * @return {number} 加算した結果\n     */\n    static add(v0, v1){\n        let out = Vec2.create();\n        out[0] = v0[0] + v1[0];\n        out[1] = v0[1] + v1[1];\n        return out;\n    }\n    /**\n     * ２つのベクトルを減算した結果を返す\n     * @param {Vec2} v0 - ２つの要素を持つベクトル\n     * @param {Vec2} v1 - ２つの要素を持つベクトル\n     * @return {number} 減算した結果\n     */\n    static sub(v0, v1){\n        let out = Vec2.create();\n        out[0] = v0[0] - v1[0];\n        out[1] = v0[1] - v1[1];\n        return out;\n    }\n    /**\n     * ２つのベクトルの要素同士を乗算した結果を返す\n     * @param {Vec2} v0 - ２つの要素を持つベクトル\n     * @param {Vec2} v1 - ２つの要素を持つベクトル\n     * @return {number} 乗算した結果\n     */\n    static multiply(v0, v1){\n        let out = Vec2.create();\n        out[0] = v0[0] * v1[0];\n        out[1] = v0[1] * v1[1];\n        return out;\n    }\n    /**\n     * ２つのベクトルの要素同士を除算した結果を返す\n     * @param {Vec2} v0 - ２つの要素を持つベクトル\n     * @param {Vec2} v1 - ２つの要素を持つベクトル\n     * @return {number} 除算した結果\n     */\n    static divide(v0, v1){\n        let out = Vec2.create();\n        out[0] = v0[0] / v1[0];\n        out[1] = v0[1] / v1[1];\n        return out;\n    }\n    /**\n     * ２つのベクトルの内積の結果を返す\n     * @param {Vec2} v0 - ２つの要素を持つベクトル\n     * @param {Vec2} v1 - ２つの要素を持つベクトル\n     * @return {number} 内積の結果\n     */\n    static dot(v0, v1){\n        return v0[0] * v1[0] + v0[1] * v1[1];\n    }\n    /**\n     * ２つのベクトルの外積の結果を返す\n     * @param {Vec2} v0 - ２つの要素を持つベクトル\n     * @param {Vec2} v1 - ２つの要素を持つベクトル\n     * @return {number} 外積の結果\n     */\n    static cross(v0, v1){\n        return v0[0] * v1[1] - v0[1] * v1[0];\n    }\n    /**\n     * ２つのベクトル間を補間した結果を返す\n     * @param {Vec2} v0 - ３つの要素を持つベクトル\n     * @param {Vec2} v1 - ３つの要素を持つベクトル\n     * @param {number} t - 補間係数\n     * @return {Vec2} 補間の結果\n     */\n    static lerp(v0, v1, t){\n        const time = Math.min(Math.max(t, 0.0), 1.0);\n        if(time === 0.0){return Vec2.copy(v0);}\n        if(time === 1.0){return Vec2.copy(v1);}\n        let out = Vec2.sub(v1, v0);\n        out[0] = v0[0] + out[0] * time;\n        out[1] = v0[1] + out[1] * time;\n        return out;\n    }\n}\n\n/**\n * Qtn\n * @class Qtn\n */\nexport class Qtn {\n    /**\n     * ４つの要素からなるクォータニオンのデータ構造を生成する（虚部 x, y, z, 実部 w の順序で定義）\n     * @return {Float32Array} クォータニオンデータ格納用の配列\n     */\n    static create(){\n        return new Float32Array(4);\n    }\n    /**\n     * クォータニオンを初期化する（引数が与えられた場合そのクォータニオンに結果を代入する）\n     * @param {Qtn} [source] - 初期化するクォータニオン\n     * @return {Qtn} 結果のクォータニオン\n     */\n    static identity(source){\n        let out = source;\n        if(out == null){out = Qtn.create();}\n        out[0] = 0; out[1] = 0; out[2] = 0; out[3] = 1;\n        return out;\n    }\n    /**\n     * クォータニオンの値をコピーして返す（第二引数が与えられた場合そのクォータニオンがコピー先となる）\n     * @param {Qtn} target - コピー元のクォータニオン\n     * @param {Qtn} [source] - コピー先のクォータニオン\n     * @return {Qtn} コピー先のクォータニオン\n     */\n    static copy(target, source){\n        let out = source;\n        if(target == null){\n            throw new Error('Qtn.copy: invalid argument');\n        }\n        if(out == null){out = Qtn.create();}\n        out[0] = target[0];\n        out[1] = target[1];\n        out[2] = target[2];\n        out[3] = target[3];\n        return out;\n    }\n    /**\n     * 共役四元数を生成して返す（第二引数が与えられた場合そのクォータニオンに結果を代入する）\n     * @param {Qtn} qtn - 元となるクォータニオン\n     * @param {Qtn} [source] - 結果を格納するクォータニオン\n     * @return {Qtn} 結果のクォータニオン\n     */\n    static inverse(qtn, source){\n        let out = source;\n        if(out == null){out = Qtn.create();}\n        out[0] = -qtn[0];\n        out[1] = -qtn[1];\n        out[2] = -qtn[2];\n        out[3] =  qtn[3];\n        return out;\n    }\n    /**\n     * 虚部を正規化して返す\n     * @param {Qtn} source - 元となるクォータニオン\n     * @return {Qtn} 結果のクォータニオン\n     */\n    static normalize(source){\n        let x = source[0], y = source[1], z = source[2];\n        let l = Math.sqrt(x * x + y * y + z * z);\n        if(l === 0){\n            source[0] = 0;\n            source[1] = 0;\n            source[2] = 0;\n        }else{\n            l = 1 / l;\n            source[0] = x * l;\n            source[1] = y * l;\n            source[2] = z * l;\n        }\n        return source;\n    }\n    /**\n     * クォータニオンを乗算した結果を返す（第三引数が与えられた場合そのクォータニオンに結果を代入する）\n     * @param {Qtn} qtn0 - 乗算されるクォータニオン\n     * @param {Qtn} qtn1 - 乗算するクォータニオン\n     * @param {Qtn} [source] - 結果を格納するクォータニオン\n     * @return {Qtn} 結果のクォータニオン\n     */\n    static multiply(qtn0, qtn1, source){\n        let out = source;\n        if(out == null){out = Qtn.create();}\n        let ax = qtn0[0], ay = qtn0[1], az = qtn0[2], aw = qtn0[3];\n        let bx = qtn1[0], by = qtn1[1], bz = qtn1[2], bw = qtn1[3];\n        out[0] = ax * bw + aw * bx + ay * bz - az * by;\n        out[1] = ay * bw + aw * by + az * bx - ax * bz;\n        out[2] = az * bw + aw * bz + ax * by - ay * bx;\n        out[3] = aw * bw - ax * bx - ay * by - az * bz;\n        return out;\n    }\n    /**\n     * クォータニオンに回転を適用し返す（第三引数が与えられた場合そのクォータニオンに結果を代入する）\n     * @param {number} angle - 回転する量（ラジアン）\n     * @param {Vec3} axis - ３つの要素を持つ軸ベクトル\n     * @param {Qtn} [source] - 結果を格納するクォータニオン\n     * @return {Qtn} 結果のクォータニオン\n     */\n    static rotate(angle, axis, source){\n        let out = source;\n        if(out == null){out = Qtn.create();}\n        let a = axis[0], b = axis[1], c = axis[2];\n        let sq = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n        if(sq !== 0){\n            let l = 1 / sq;\n            a *= l;\n            b *= l;\n            c *= l;\n        }\n        let s = Math.sin(angle * 0.5);\n        out[0] = a * s;\n        out[1] = b * s;\n        out[2] = c * s;\n        out[3] = Math.cos(angle * 0.5);\n        return out;\n    }\n    /**\n     * ベクトルにクォータニオンを適用し返す（第三引数が与えられた場合そのベクトルに結果を代入する）\n     * @param {Vec3} vec - ３つの要素を持つベクトル\n     * @param {Qtn} qtn - クォータニオン\n     * @param {Vec3} [source] - ３つの要素を持つベクトル\n     * @return {Vec3} 結果のベクトル\n     */\n    static toVecIII(vec, qtn, source){\n        let out = source;\n        if(out == null){out = Vec3.create();}\n        let qp = Qtn.create();\n        let qq = Qtn.create();\n        let qr = Qtn.create();\n        Qtn.inverse(qtn, qr);\n        qp[0] = vec[0];\n        qp[1] = vec[1];\n        qp[2] = vec[2];\n        Qtn.multiply(qr, qp, qq);\n        Qtn.multiply(qq, qtn, qr);\n        out[0] = qr[0];\n        out[1] = qr[1];\n        out[2] = qr[2];\n        return out;\n    }\n    /**\n     * 4x4 行列にクォータニオンを適用し返す（第二引数が与えられた場合その行列に結果を代入する）\n     * @param {Qtn} qtn - クォータニオン\n     * @param {Mat4} [source] - 4x4 行列\n     * @return {Mat4} 結果の行列\n     */\n    static toMatIV(qtn, source){\n        let out = source;\n        if(out == null){out = Mat4.create();}\n        let x = qtn[0], y = qtn[1], z = qtn[2], w = qtn[3];\n        let x2 = x + x, y2 = y + y, z2 = z + z;\n        let xx = x * x2, xy = x * y2, xz = x * z2;\n        let yy = y * y2, yz = y * z2, zz = z * z2;\n        let wx = w * x2, wy = w * y2, wz = w * z2;\n        out[0]  = 1 - (yy + zz);\n        out[1]  = xy - wz;\n        out[2]  = xz + wy;\n        out[3]  = 0;\n        out[4]  = xy + wz;\n        out[5]  = 1 - (xx + zz);\n        out[6]  = yz - wx;\n        out[7]  = 0;\n        out[8]  = xz - wy;\n        out[9]  = yz + wx;\n        out[10] = 1 - (xx + yy);\n        out[11] = 0;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = 0;\n        out[15] = 1;\n        return out;\n    }\n    /**\n     * ２つのクォータニオンの球面線形補間を行った結果を返す（第四引数が与えられた場合そのクォータニオンに結果を代入する）\n     * @param {Qtn} qtn0 - クォータニオン\n     * @param {Qtn} qtn1 - クォータニオン\n     * @param {number} time - 補間係数（0.0 から 1.0 で指定）\n     * @param {Qtn} [source] - 結果を格納するクォータニオン\n     * @return {Qtn} 結果のクォータニオン\n     */\n    static slerp(qtn0, qtn1, time, source){\n        let out = source;\n        if(out == null){out = Qtn.create();}\n        let ht = qtn0[0] * qtn1[0] + qtn0[1] * qtn1[1] + qtn0[2] * qtn1[2] + qtn0[3] * qtn1[3];\n        let hs = 1.0 - ht * ht;\n        if(hs <= 0.0){\n            out[0] = qtn0[0];\n            out[1] = qtn0[1];\n            out[2] = qtn0[2];\n            out[3] = qtn0[3];\n        }else{\n            hs = Math.sqrt(hs);\n            if(Math.abs(hs) < 0.0001){\n                out[0] = (qtn0[0] * 0.5 + qtn1[0] * 0.5);\n                out[1] = (qtn0[1] * 0.5 + qtn1[1] * 0.5);\n                out[2] = (qtn0[2] * 0.5 + qtn1[2] * 0.5);\n                out[3] = (qtn0[3] * 0.5 + qtn1[3] * 0.5);\n            }else{\n                let ph = Math.acos(ht);\n                let pt = ph * time;\n                let t0 = Math.sin(ph - pt) / hs;\n                let t1 = Math.sin(pt) / hs;\n                out[0] = qtn0[0] * t0 + qtn1[0] * t1;\n                out[1] = qtn0[1] * t0 + qtn1[1] * t1;\n                out[2] = qtn0[2] * t0 + qtn1[2] * t1;\n                out[3] = qtn0[3] * t0 + qtn1[3] * t1;\n            }\n        }\n        return out;\n    }\n}\n\n/**\n * Geometry\n * @class Geometry\n */\nexport class Geometry {\n    /**\n     * 板ポリゴンの頂点情報を生成する\n     * @param {number} width - 板ポリゴンの一辺の幅\n     * @param {number} height - 板ポリゴンの一辺の高さ\n     * @param {Array.<number>} color - RGBA を 0.0 から 1.0 の範囲で指定した配列\n     * @return {object}\n     * @property {Array.<number>} position - 頂点座標\n     * @property {Array.<number>} normal - 頂点法線\n     * @property {Array.<number>} color - 頂点カラー\n     * @property {Array.<number>} texCoord - テクスチャ座標\n     * @property {Array.<number>} index - 頂点インデックス（gl.TRIANGLES）\n     * @example\n     * let planeData = Geometry.plane(2.0, 2.0, [1.0, 1.0, 1.0, 1.0]);\n     */\n    static plane(width, height, color){\n        let w, h;\n        w = width / 2;\n        h = height / 2;\n        let pos = [\n            -w,  h,  0.0,\n             w,  h,  0.0,\n            -w, -h,  0.0,\n             w, -h,  0.0\n        ];\n        let nor = [\n            0.0, 0.0, 1.0,\n            0.0, 0.0, 1.0,\n            0.0, 0.0, 1.0,\n            0.0, 0.0, 1.0\n        ];\n        let col = [\n            color[0], color[1], color[2], color[3],\n            color[0], color[1], color[2], color[3],\n            color[0], color[1], color[2], color[3],\n            color[0], color[1], color[2], color[3]\n        ];\n        let st  = [\n            0.0, 0.0,\n            1.0, 0.0,\n            0.0, 1.0,\n            1.0, 1.0\n        ];\n        let idx = [\n            0, 1, 2,\n            2, 1, 3\n        ];\n        return {position: pos, normal: nor, color: col, texCoord: st, index: idx}\n    }\n\n    /**\n     * 円（XY 平面展開）の頂点情報を生成する\n     * @param {number} split - 円の円周の分割数\n     * @param {number} rad - 円の半径\n     * @param {Array.<number>} color - RGBA を 0.0 から 1.0 の範囲で指定した配列\n     * @return {object}\n     * @property {Array.<number>} position - 頂点座標\n     * @property {Array.<number>} normal - 頂点法線\n     * @property {Array.<number>} color - 頂点カラー\n     * @property {Array.<number>} texCoord - テクスチャ座標\n     * @property {Array.<number>} index - 頂点インデックス（gl.TRIANGLES）\n     * @example\n     * let circleData = Geometry.circle(64, 1.0, [1.0, 1.0, 1.0, 1.0]);\n     */\n    static circle(split, rad, color){\n        let i, j = 0;\n        let pos = [], nor = [],\n            col = [], st  = [], idx = [];\n        pos.push(0.0, 0.0, 0.0);\n        nor.push(0.0, 0.0, 1.0);\n        col.push(color[0], color[1], color[2], color[3]);\n        st.push(0.5, 0.5);\n        for(i = 0; i < split; i++){\n            let r = Math.PI * 2.0 / split * i;\n            let rx = Math.cos(r);\n            let ry = Math.sin(r);\n            pos.push(rx * rad, ry * rad, 0.0);\n            nor.push(0.0, 0.0, 1.0);\n            col.push(color[0], color[1], color[2], color[3]);\n            st.push((rx + 1.0) * 0.5, 1.0 - (ry + 1.0) * 0.5);\n            if(i === split - 1){\n                idx.push(0, j + 1, 1);\n            }else{\n                idx.push(0, j + 1, j + 2);\n            }\n            ++j;\n        }\n        return {position: pos, normal: nor, color: col, texCoord: st, index: idx}\n    }\n\n    /**\n     * キューブの頂点情報を生成する\n     * @param {number} side - 正立方体の一辺の長さ\n     * @param {Array.<number>} color - RGBA を 0.0 から 1.0 の範囲で指定した配列\n     * @return {object}\n     * @property {Array.<number>} position - 頂点座標\n     * @property {Array.<number>} normal - 頂点法線 ※キューブの中心から各頂点に向かって伸びるベクトルなので注意\n     * @property {Array.<number>} color - 頂点カラー\n     * @property {Array.<number>} texCoord - テクスチャ座標\n     * @property {Array.<number>} index - 頂点インデックス（gl.TRIANGLES）\n     * @example\n     * let cubeData = Geometry.cube(2.0, [1.0, 1.0, 1.0, 1.0]);\n     */\n    static cube(side, color){\n        let hs = side * 0.5;\n        let pos = [\n            -hs, -hs,  hs,  hs, -hs,  hs,  hs,  hs,  hs, -hs,  hs,  hs,\n            -hs, -hs, -hs, -hs,  hs, -hs,  hs,  hs, -hs,  hs, -hs, -hs,\n            -hs,  hs, -hs, -hs,  hs,  hs,  hs,  hs,  hs,  hs,  hs, -hs,\n            -hs, -hs, -hs,  hs, -hs, -hs,  hs, -hs,  hs, -hs, -hs,  hs,\n             hs, -hs, -hs,  hs,  hs, -hs,  hs,  hs,  hs,  hs, -hs,  hs,\n            -hs, -hs, -hs, -hs, -hs,  hs, -hs,  hs,  hs, -hs,  hs, -hs\n        ];\n        let v = 1.0 / Math.sqrt(3.0);\n        let nor = [\n            -v, -v,  v,  v, -v,  v,  v,  v,  v, -v,  v,  v,\n            -v, -v, -v, -v,  v, -v,  v,  v, -v,  v, -v, -v,\n            -v,  v, -v, -v,  v,  v,  v,  v,  v,  v,  v, -v,\n            -v, -v, -v,  v, -v, -v,  v, -v,  v, -v, -v,  v,\n             v, -v, -v,  v,  v, -v,  v,  v,  v,  v, -v,  v,\n            -v, -v, -v, -v, -v,  v, -v,  v,  v, -v,  v, -v\n        ];\n        let col = [];\n        for(let i = 0; i < pos.length / 3; i++){\n            col.push(color[0], color[1], color[2], color[3]);\n        }\n        let st = [\n            0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n            0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n            0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n            0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n            0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n            0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0\n        ];\n        let idx = [\n             0,  1,  2,  0,  2,  3,\n             4,  5,  6,  4,  6,  7,\n             8,  9, 10,  8, 10, 11,\n            12, 13, 14, 12, 14, 15,\n            16, 17, 18, 16, 18, 19,\n            20, 21, 22, 20, 22, 23\n        ];\n        return {position: pos, normal: nor, color: col, texCoord: st, index: idx}\n    }\n\n    /**\n     * 三角錐の頂点情報を生成する\n     * @param {number} split - 底面円の円周の分割数\n     * @param {number} rad - 底面円の半径\n     * @param {number} height - 三角錐の高さ\n     * @param {Array.<number>} color - RGBA を 0.0 から 1.0 の範囲で指定した配列\n     * @return {object}\n     * @property {Array.<number>} position - 頂点座標\n     * @property {Array.<number>} normal - 頂点法線\n     * @property {Array.<number>} color - 頂点カラー\n     * @property {Array.<number>} texCoord - テクスチャ座標\n     * @property {Array.<number>} index - 頂点インデックス（gl.TRIANGLES）\n     * @example\n     * let coneData = Geometry.cone(64, 1.0, 2.0, [1.0, 1.0, 1.0, 1.0]);\n     */\n    static cone(split, rad, height, color){\n        let i, j = 0;\n        let h = height / 2.0;\n        let pos = [], nor = [],\n            col = [], st  = [], idx = [];\n        pos.push(0.0, -h, 0.0);\n        nor.push(0.0, -1.0, 0.0);\n        col.push(color[0], color[1], color[2], color[3]);\n        st.push(0.5, 0.5);\n        for(i = 0; i <= split; i++){\n            let r = Math.PI * 2.0 / split * i;\n            let rx = Math.cos(r);\n            let rz = Math.sin(r);\n            pos.push(\n                rx * rad, -h, rz * rad,\n                rx * rad, -h, rz * rad\n            );\n            nor.push(\n                0.0, -1.0, 0.0,\n                rx, 0.0, rz\n            );\n            col.push(\n                color[0], color[1], color[2], color[3],\n                color[0], color[1], color[2], color[3]\n            );\n            st.push(\n                (rx + 1.0) * 0.5, 1.0 - (rz + 1.0) * 0.5,\n                (rx + 1.0) * 0.5, 1.0 - (rz + 1.0) * 0.5\n            );\n            if(i !== split){\n                idx.push(0, j + 1, j + 3);\n                idx.push(j + 4, j + 2, split * 2 + 3);\n            }\n            j += 2;\n        }\n        pos.push(0.0, h, 0.0);\n        nor.push(0.0, 1.0, 0.0);\n        col.push(color[0], color[1], color[2], color[3]);\n        st.push(0.5, 0.5);\n        return {position: pos, normal: nor, color: col, texCoord: st, index: idx}\n    }\n\n    /**\n     * 円柱の頂点情報を生成する\n     * @param {number} split - 円柱の円周の分割数\n     * @param {number} topRad - 円柱の天面の半径\n     * @param {number} bottomRad - 円柱の底面の半径\n     * @param {number} height - 円柱の高さ\n     * @param {Array.<number>} color - RGBA を 0.0 から 1.0 の範囲で指定した配列\n     * @return {object}\n     * @property {Array.<number>} position - 頂点座標\n     * @property {Array.<number>} normal - 頂点法線\n     * @property {Array.<number>} color - 頂点カラー\n     * @property {Array.<number>} texCoord - テクスチャ座標\n     * @property {Array.<number>} index - 頂点インデックス（gl.TRIANGLES）\n     * @example\n     * let cylinderData = Geometry.cylinder(64, 0.5, 1.0, 2.0, [1.0, 1.0, 1.0, 1.0]);\n     */\n    static cylinder(split, topRad, bottomRad, height, color){\n        let i, j = 2;\n        let h = height / 2.0;\n        let pos = [], nor = [],\n            col = [], st  = [], idx = [];\n        pos.push(0.0, h, 0.0, 0.0, -h, 0.0,);\n        nor.push(0.0, 1.0, 0.0, 0.0, -1.0, 0.0);\n        col.push(\n            color[0], color[1], color[2], color[3],\n            color[0], color[1], color[2], color[3]\n        );\n        st.push(0.5, 0.5, 0.5, 0.5);\n        for(i = 0; i <= split; i++){\n            let r = Math.PI * 2.0 / split * i;\n            let rx = Math.cos(r);\n            let rz = Math.sin(r);\n            pos.push(\n                rx * topRad,  h, rz * topRad,\n                rx * topRad,  h, rz * topRad,\n                rx * bottomRad, -h, rz * bottomRad,\n                rx * bottomRad, -h, rz * bottomRad\n            );\n            nor.push(\n                0.0, 1.0, 0.0,\n                rx, 0.0, rz,\n                0.0, -1.0, 0.0,\n                rx, 0.0, rz\n            );\n            col.push(\n                color[0], color[1], color[2], color[3],\n                color[0], color[1], color[2], color[3],\n                color[0], color[1], color[2], color[3],\n                color[0], color[1], color[2], color[3]\n            );\n            st.push(\n                (rx + 1.0) * 0.5, 1.0 - (rz + 1.0) * 0.5,\n                1.0 - i / split, 0.0,\n                (rx + 1.0) * 0.5, 1.0 - (rz + 1.0) * 0.5,\n                1.0 - i / split, 1.0\n            );\n            if(i !== split){\n                idx.push(\n                    0, j + 4, j,\n                    1, j + 2, j + 6,\n                    j + 5, j + 7, j + 1,\n                    j + 1, j + 7, j + 3\n                );\n            }\n            j += 4;\n        }\n        return {position: pos, normal: nor, color: col, texCoord: st, index: idx}\n    }\n\n    /**\n     * 球体の頂点情報を生成する\n     * @param {number} row - 球の縦方向（緯度方向）の分割数\n     * @param {number} column - 球の横方向（経度方向）の分割数\n     * @param {number} rad - 球の半径\n     * @param {Array.<number>} color - RGBA を 0.0 から 1.0 の範囲で指定した配列\n     * @return {object}\n     * @property {Array.<number>} position - 頂点座標\n     * @property {Array.<number>} normal - 頂点法線\n     * @property {Array.<number>} color - 頂点カラー\n     * @property {Array.<number>} texCoord - テクスチャ座標\n     * @property {Array.<number>} index - 頂点インデックス（gl.TRIANGLES）\n     * @example\n     * let sphereData = Geometry.sphere(64, 64, 1.0, [1.0, 1.0, 1.0, 1.0]);\n     */\n    static sphere(row, column, rad, color){\n        let i, j;\n        let pos = [], nor = [],\n            col = [], st  = [], idx = [];\n        for(i = 0; i <= row; i++){\n            let r = Math.PI / row * i;\n            let ry = Math.cos(r);\n            let rr = Math.sin(r);\n            for(j = 0; j <= column; j++){\n                let tr = Math.PI * 2 / column * j;\n                let tx = rr * rad * Math.cos(tr);\n                let ty = ry * rad;\n                let tz = rr * rad * Math.sin(tr);\n                let rx = rr * Math.cos(tr);\n                let rz = rr * Math.sin(tr);\n                pos.push(tx, ty, tz);\n                nor.push(rx, ry, rz);\n                col.push(color[0], color[1], color[2], color[3]);\n                st.push(1 - 1 / column * j, 1 / row * i);\n            }\n        }\n        for(i = 0; i < row; i++){\n            for(j = 0; j < column; j++){\n                let r = (column + 1) * i + j;\n                idx.push(r, r + 1, r + column + 2);\n                idx.push(r, r + column + 2, r + column + 1);\n            }\n        }\n        return {position: pos, normal: nor, color: col, texCoord: st, index: idx}\n    }\n\n    /**\n     * トーラスの頂点情報を生成する\n     * @param {number} row - 輪の分割数\n     * @param {number} column - パイプ断面の分割数\n     * @param {number} irad - パイプ断面の半径\n     * @param {number} orad - パイプ全体の半径\n     * @param {Array.<number>} color - RGBA を 0.0 から 1.0 の範囲で指定した配列\n     * @return {object}\n     * @property {Array.<number>} position - 頂点座標\n     * @property {Array.<number>} normal - 頂点法線\n     * @property {Array.<number>} color - 頂点カラー\n     * @property {Array.<number>} texCoord - テクスチャ座標\n     * @property {Array.<number>} index - 頂点インデックス（gl.TRIANGLES）\n     * @example\n     * let torusData = Geometry.torus(64, 64, 0.25, 0.75, [1.0, 1.0, 1.0, 1.0]);\n     */\n    static torus(row, column, irad, orad, color){\n        let i, j;\n        let pos = [], nor = [],\n            col = [], st  = [], idx = [];\n        for(i = 0; i <= row; i++){\n            let r = Math.PI * 2 / row * i;\n            let rr = Math.cos(r);\n            let ry = Math.sin(r);\n            for(j = 0; j <= column; j++){\n                let tr = Math.PI * 2 / column * j;\n                let tx = (rr * irad + orad) * Math.cos(tr);\n                let ty = ry * irad;\n                let tz = (rr * irad + orad) * Math.sin(tr);\n                let rx = rr * Math.cos(tr);\n                let rz = rr * Math.sin(tr);\n                let rs = 1 / column * j;\n                let rt = 1 / row * i + 0.5;\n                if(rt > 1.0){rt -= 1.0;}\n                rt = 1.0 - rt;\n                pos.push(tx, ty, tz);\n                nor.push(rx, ry, rz);\n                col.push(color[0], color[1], color[2], color[3]);\n                st.push(rs, rt);\n            }\n        }\n        for(i = 0; i < row; i++){\n            for(j = 0; j < column; j++){\n                let r = (column + 1) * i + j;\n                idx.push(r, r + column + 1, r + 1);\n                idx.push(r + column + 1, r + column + 2, r + 1);\n            }\n        }\n        return {position: pos, normal: nor, color: col, texCoord: st, index: idx}\n    }\n\n    /**\n     * 正二十面体の頂点情報を生成する\n     * @param {number} rad - サイズ（黄金比に対する比率）\n     * @param {Array.<number>} color - RGBA を 0.0 から 1.0 の範囲で指定した配列\n     * @return {object}\n     * @property {Array.<number>} position - 頂点座標\n     * @property {Array.<number>} normal - 頂点法線\n     * @property {Array.<number>} color - 頂点カラー\n     * @property {Array.<number>} texCoord - テクスチャ座標\n     * @property {Array.<number>} index - 頂点インデックス（gl.TRIANGLES）\n     * @example\n     * let icosaData = Geometry.icosahedron(1.0, [1.0, 1.0, 1.0, 1.0]);\n     */\n    static icosahedron(rad, color){\n        let i, j;\n        let pos = [], nor = [],\n            col = [], st  = [], idx = [];\n        let c = (1.0 + Math.sqrt(5.0)) / 2.0;\n        let t = c * rad;\n        let l = Math.sqrt(1.0 + c * c);\n        let r = [1.0 / l, c / l];\n        pos = [\n            -rad,    t,  0.0,  rad,    t,  0.0, -rad,   -t,  0.0,  rad,   -t,  0.0,\n             0.0, -rad,    t,  0.0,  rad,    t,  0.0, -rad,   -t,  0.0,  rad,   -t,\n               t,  0.0, -rad,    t,  0.0,  rad,   -t,  0.0, -rad,   -t,  0.0,  rad\n        ];\n        nor = [\n            -r[0],  r[1],   0.0,  r[0],  r[1],   0.0, -r[0], -r[1],   0.0,  r[0], -r[1],   0.0,\n              0.0, -r[0],  r[1],   0.0,  r[0],  r[1],   0.0, -r[0], -r[1],   0.0,  r[0], -r[1],\n             r[1],   0.0, -r[0],  r[1],   0.0,  r[0], -r[1],   0.0, -r[0], -r[1],   0.0,  r[0]\n        ];\n        col = [\n            color[0], color[1], color[2], color[3], color[0], color[1], color[2], color[3],\n            color[0], color[1], color[2], color[3], color[0], color[1], color[2], color[3],\n            color[0], color[1], color[2], color[3], color[0], color[1], color[2], color[3],\n            color[0], color[1], color[2], color[3], color[0], color[1], color[2], color[3],\n            color[0], color[1], color[2], color[3], color[0], color[1], color[2], color[3],\n            color[0], color[1], color[2], color[3], color[0], color[1], color[2], color[3]\n        ];\n        for(i = 0, j = nor.length; i < j; i += 3){\n            let u = (Math.atan2(nor[i + 2], -nor[i]) + Math.PI) / (Math.PI * 2.0);\n            let v = 1.0 - (nor[i + 1] + 1.0) / 2.0;\n            st.push(u, v);\n        }\n        idx = [\n             0, 11,  5,  0,  5,  1,  0,  1,  7,  0,  7, 10,  0, 10, 11,\n             1,  5,  9,  5, 11,  4, 11, 10,  2, 10,  7,  6,  7,  1,  8,\n             3,  9,  4,  3,  4,  2,  3,  2,  6,  3,  6,  8,  3,  8,  9,\n             4,  9,  5,  2,  4, 11,  6,  2, 10,  8,  6,  7,  9,  8,  1\n        ];\n        return {position: pos, normal: nor, color: col, texCoord: st, index: idx}\n    }\n}\n\n","import vertexShader from \"./glsl/shape.vert\"\r\nimport fragmentShader from \"./glsl/shape.frag\"\r\nimport {Mat4} from './minMatrix/minMatrix'\r\n\r\nclass Common {\r\n  constructor() {\r\n    this.c = null // canvas\r\n    this.gl = null\r\n    this.v_shader = null\r\n    this.f_shader = null\r\n    this.prg = null\r\n    this.attLocation = new Array()\r\n    this.position_vbo = null\r\n    this.color_vbo = null\r\n    this.normal_vbo = null\r\n    this.m = null // matIV\r\n    this.mMatrix = null\r\n    this.vMatrix = null\r\n    this.pMatrix = null\r\n    this.tmpMatrix = null\r\n    this.mvpMatrix = null\r\n    this.uniLocation = new Array()\r\n\r\n    this.ibo = null\r\n\r\n    this.size = {\r\n      windowW: null,\r\n      windowH: null\r\n    }\r\n\r\n    this.attStride = new Array()\r\n\r\n    this.vertex_position = [\r\n      0.0, 1.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n     -1.0, 0.0, 0.0,\r\n      0.0,-1.0, 0.0\r\n    ]\r\n    this.vertex_color = [\r\n      1.0, 1.0, 0.0, 1.0,\r\n      0.0, 1.0, 1.0, 1.0,\r\n      1.0, 0.0, 1.0, 1.0,\r\n      0.0, 0.0, 1.0, 1.0\r\n    ]\r\n    this.index = [\r\n      0, 1, 2,\r\n      1, 2, 3\r\n    ]\r\n\r\n    this.count = 0\r\n\r\n    this.torusData = null\r\n    this.position = null\r\n    this.normal = null\r\n\r\n    this.lightDirection = null\r\n    this.eyeDirection = null\r\n    this.ambientCoor = null\r\n  }\r\n\r\n  init($canvas) {\r\n    this.setSize()\r\n\r\n    this.c = $canvas\r\n    this.c.width = this.size.windowW\r\n    this.c.height = this.size.windowH\r\n    this.gl = this.c.getContext('webgl') || this.c.getContext('experimental-webgl')\r\n    if (this.gl === null) {\r\n      alert(\"WebGL を初期化できません。ブラウザーまたはマシンがサポートしていない可能性があります。\");\r\n      return;\r\n    }\r\n\r\n    this.v_shader = this.createShader('v', this.gl)\r\n    this.f_shader = this.createShader('f', this.gl)\r\n    // プログラムオブジェクトの生成とリンク\r\n    this.prg = this.createProgram(this.v_shader,this.f_shader,this.gl)\r\n\r\n    this.attLocation[0] = this.gl.getAttribLocation(this.prg, 'position')\r\n    this.attLocation[1] = this.gl.getAttribLocation(this.prg, 'normal')\r\n    this.attLocation[2] = this.gl.getAttribLocation(this.prg, 'color')\r\n\r\n    this.attStride[0] = 3\r\n    this.attStride[1] = 3\r\n    this.attStride[2] = 4\r\n\r\n    // toras\r\n    this.torusData = this.torus(3, 5, 4.0, 5.0)\r\n    this.position  = this.torusData.p\r\n    this.normal    = this.torusData.n\r\n    this.color     = this.torusData.c\r\n    this.index     = this.torusData.i\r\n\r\n    this.position_vbo = this.createVBO(this.position, this.gl)\r\n    this.normal_vbo   = this.createVBO(this.normal, this.gl)\r\n    this.color_vbo    = this.createVBO(this.color, this.gl)\r\n\r\n    // vboを登録\r\n    this.setAttribute([this.position_vbo, this.normal_vbo, this.color_vbo], this.attLocation, this.attStride, this.gl)\r\n\r\n    // IBOの生成\r\n    this.ibo = this.createIBO(this.index)\r\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ibo)\r\n\r\n    // uniformLocationの取得\r\n    this.uniLocation[0] = this.gl.getUniformLocation(this.prg, 'mvpMatrix')\r\n    this.uniLocation[1] = this.gl.getUniformLocation(this.prg, 'invMatrix')\r\n    this.uniLocation[2] = this.gl.getUniformLocation(this.prg, 'lightDirection')\r\n    this.uniLocation[3] = this.gl.getUniformLocation(this.prg, 'eyeDirection')\r\n    this.uniLocation[4] = this.gl.getUniformLocation(this.prg, 'ambientColor')\r\n\r\n    this.m = new Mat4()\r\n\r\n    this.mMatrix = this.m.identity(this.m.create())\r\n    this.vMatrix = this.m.identity(this.m.create())\r\n    this.pMatrix = this.m.identity(this.m.create())\r\n    this.tmpMatrix = this.m.identity(this.m.create())\r\n    this.mvpMatrix = this.m.identity(this.m.create())\r\n    this.invMatrix = this.m.identity(this.m.create())\r\n\r\n    // 平行光源の向き\r\n    this.lightDirection = [-1.0, 1.0, 1.0]\r\n    // 視点ベクトル\r\n    this.eyeDirection = [0.0, 1.0, 20.0]\r\n    // 環境光の色\r\n    this.ambientCoor = [0.1, 0.0, 0.2, 1.0]\r\n\r\n    // ビューxプロジェクション座標変換行列\r\n    this.m.lookAt([0.0,0.0,20.0], [0, 0, 0], [0, 1, 0], this.vMatrix)\r\n    this.m.perspective(45, this.c.width / this.c.height, 0.1, 100, this.pMatrix)\r\n    this.m.multiply(this.pMatrix, this.vMatrix, this.tmpMatrix)\r\n\r\n    this.gl.enable(this.gl.DEPTH_TEST)\r\n    this.gl.depthFunc(this.gl.LEQUAL)\r\n    this.gl.enable(this.gl.CULL_FACE)\r\n\r\n    this.update()\r\n  }\r\n\r\n  setSize() {\r\n    this.size = {\r\n      windowW: window.innerWidth,\r\n      windowH: window.innerHeight\r\n    }\r\n  }\r\n  // シェーダを生成する関数\r\n  createShader(name, gl) {\r\n    let shader,shader_text\r\n    switch(name) {\r\n      case 'v':\r\n        shader = gl.createShader(gl.VERTEX_SHADER)\r\n        shader_text = vertexShader\r\n        break\r\n      case 'f':\r\n        shader = gl.createShader(gl.FRAGMENT_SHADER)\r\n        shader_text = fragmentShader\r\n        break\r\n      default:\r\n        break\r\n    }\r\n\r\n    // 生成されたシェーダにソースを割り当てる\r\n    gl.shaderSource(shader,shader_text)\r\n    // コンパイル\r\n    gl.compileShader(shader)\r\n\r\n    if(gl.getShaderParameter(shader, gl.COMPILE_STATUS)){\r\n      // 成功していたらシェーダを返して終了\r\n      return shader\r\n    }else{\r\n      // 失敗していたらエラーログをアラートする\r\n      alert(gl.getShaderInfoLog(shader))\r\n    }\r\n  }\r\n  // プログラムオブジェクトを生成しシェーダをリンクする関数\r\n  createProgram(v, s, gl) {\r\n    const program = gl.createProgram()\r\n\r\n    gl.attachShader(program, v)\r\n    gl.attachShader(program, s)\r\n\r\n    gl.linkProgram(program)\r\n\r\n    if(gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n      gl.useProgram(program)\r\n      return program\r\n    } else {\r\n      alert(gl.getProgramIngoLog(program))\r\n    }\r\n  }\r\n  // VBOを生成\r\n  createVBO(data, gl) {\r\n    const vbo = gl.createBuffer()\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo)\r\n\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, null)\r\n\r\n    return vbo\r\n  }\r\n  // VBOをバインドし登録する関数\r\n  setAttribute(vboArray, attL, attS, gl) {\r\n    for(let i in vboArray) {\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[i])\r\n      gl.enableVertexAttribArray(attL[i])\r\n      gl.vertexAttribPointer(attL[i], attS[i], gl.FLOAT, false, 0, 0)\r\n    }\r\n  }\r\n\r\n  update() {\r\n    window.requestAnimationFrame(this.update.bind(this))\r\n    // canvas初期化\r\n    this.gl.clearColor(0.0, 0.0, 0.0, 1.0)\r\n    this.gl.clearDepth(1.0)\r\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)\r\n\r\n    this.count++\r\n\r\n    const rad = (this.count % 360) * Math.PI / 180\r\n    // const x = Math.cos(rad) * 1.5\r\n    // const z = Math.sin(rad) * 1.5\r\n\r\n    // モデル１は円の軌道を描き移動させる\r\n    // const x = Math.cos(rad)\r\n    // const y = Math.sin(rad)\r\n    // this.m.identity(this.mMatrix)\r\n    // this.m.translate(this.mMatrix, [x, y + 1.0, 0.0], this.mMatrix)\r\n\r\n    // モデル１の座標変換行列を完成させレンダリングする\r\n    // this.m.multiply(this.tmpMatrix, this.mMatrix,this.mvpMatrix)\r\n    // this.gl.uniformMatrix4fv(this.uniLocation, false, this.mvpMatrix)\r\n    // this.gl.drawArrays(this.gl.TRIANGLES, 0, 3)\r\n\r\n    // model2はy軸を中心に回転する\r\n    // this.m.identity(this.mMatrix)\r\n    // this.m.translate(this.mMatrix, [1.0, -1.0, 0.0], this.mMatrix)\r\n    // this.m.rotate(this.mMatrix, rad, [0, 1, 0], this.mMatrix)\r\n\r\n    // model2座標変換行列を完成させレンダリング\r\n    // this.m.multiply(this.tmpMatrix, this.mMatrix, this.mvpMatrix)\r\n    // this.gl.uniformMatrix4fv(this.uniLocation, false, this.mvpMatrix)\r\n    // this.gl.drawArrays(this.gl.TRIANGLES, 0, 3)\r\n\r\n    // model3は拡大縮小する\r\n    // const s = Math.sin(rad) + 1.0\r\n    // this.m.identity(this.mMatrix)\r\n    // this.m.translate(this.mMatrix, [-1.0, -1.0, 0.0], this.mMatrix)\r\n    // this.m.scale(this.mMatrix, [s, s, 0.0], this.mMatrix)\r\n\r\n    // model3の座標変換を完成させレンダリング\r\n    // this.m.multiply(this.tmpMatrix, this.mMatrix, this.mvpMatrix)\r\n    // this.gl.uniformMatrix4fv(this.uniLocation, false, this.mvpMatrix)\r\n    // this.gl.drawArrays(this.gl.TRIANGLES, 0, 3)\r\n\r\n    // 18 19 20\r\n    // this.m.identity(this.mMatrix)\r\n    // this.m.translate(this.mMatrix, [x, 0.0, z], this.mMatrix)\r\n    // this.m.rotate(this.mMatrix, rad, [1, 0, 0], this.mMatrix)\r\n    // this.m.multiply(this.tmpMatrix, this.mMatrix, this.mvpMatrix)\r\n    // this.gl.uniformMatrix4fv(this.uniLocation, false, this.mvpMatrix)\r\n    // this.gl.drawElements(this.gl.TRIANGLES, this.index.length, this.gl.UNSIGNED_SHORT, 0)\r\n\r\n\r\n    // this.m.identity(this.mMatrix)\r\n    // this.m.translate(this.mMatrix, [-x, 0.0, -z], this.mMatrix)\r\n    // this.m.rotate(this.mMatrix, rad, [0, 1, 0], this.mMatrix)\r\n    // this.m.multiply(this.tmpMatrix, this.mMatrix, this.mvpMatrix)\r\n    // this.gl.uniformMatrix4fv(this.uniLocation, false, this.mvpMatrix)\r\n    // this.gl.drawElements(this.gl.TRIANGLES, this.index.length, this.gl.UNSIGNED_SHORT, 0)\r\n\r\n    this.m.identity(this.mMatrix)\r\n    this.m.rotate(this.mMatrix, rad, [0, 1, 1], this.mMatrix)\r\n    this.m.multiply(this.tmpMatrix, this.mMatrix, this.mvpMatrix)\r\n\r\n    this.m.inverse(this.mMatrix, this.invMatrix)\r\n\r\n    this.gl.uniformMatrix4fv(this.uniLocation[0], false, this.mvpMatrix)\r\n    this.gl.uniformMatrix4fv(this.uniLocation[1], false, this.invMatrix)\r\n    this.gl.uniform3fv(this.uniLocation[2], this.lightDirection)\r\n    this.gl.uniform3fv(this.uniLocation[3], this.eyeDirection)\r\n    this.gl.uniform4fv(this.uniLocation[4], this.ambientCoor)\r\n\r\n    this.gl.drawElements(this.gl.TRIANGLES, this.index.length, this.gl.UNSIGNED_SHORT, 0)\r\n\r\n    // コンテキストの再描画\r\n    this.gl.flush()\r\n  }\r\n\r\n  createIBO(data) {\r\n    const _ibo = this.gl.createBuffer()\r\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, _ibo)\r\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), this.gl.STATIC_DRAW)\r\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null)\r\n    return _ibo\r\n  }\r\n\r\n  /**\r\n   * トーラスモデル作成\r\n   * @param {*} row パイプを形成する円をいくつの頂点で表現するのかを指定（大きい円・カクカク度\r\n   * @param {*} column パイプをどれくらい分割するのかを指定\r\n   * @param {*} irad 生成されるパイプそのものの半径\r\n   * @param {*} orad 原点からパイプの中心までの距離（大きい円の半径\r\n   * @param {*} color\r\n   */\r\n  torus(row, column, irad, orad, color) {\r\n    let pos = new Array(),\r\n        nor = new Array(),\r\n        col = new Array(),\r\n        idx = new Array()\r\n\r\n    for(let i=0; i <= row; i++) {\r\n      let r = Math.PI * 2 / row * i\r\n      let rr = Math.cos(r)\r\n      let ry = Math.sin(r)\r\n\r\n      for(let ii=0; ii <= column; ii++) {\r\n        let tr = Math.PI * 2 / column * ii\r\n        let tx = (rr * irad + orad) * Math.cos(tr)\r\n        let ty = ry * irad\r\n        let tz = (rr * irad + orad) * Math.sin(tr)\r\n        let rx = rr * Math.cos(tr)\r\n        let rz = rr * Math.sin(tr)\r\n        let tc = this.hsva(360 / column * ii, 1, 1, 1)\r\n        if(color) tc = color\r\n        pos.push(tx, ty, tz)\r\n        nor.push(rx, ry, rz)\r\n        col.push(tc[0], tc[1], tc[2], tc[3])\r\n      }\r\n\r\n    }\r\n\r\n    for(let j=0; j<row; j++) {\r\n      for(let jj=0; jj<column; jj++) {\r\n        let r = (column + 1) * j + jj\r\n        idx.push(r, r + column + 1, r + 1)\r\n        idx.push(r + column + 1, r + column + 2, r + 1)\r\n      }\r\n    }\r\n\r\n    return {p: pos, n: nor, c: col, i: idx}\r\n  }\r\n\r\n  hsva(h, s, v, a) {\r\n    if(s > 1 || v > 1 || a > 1) return\r\n    let th = h % 360\r\n    let i = Math.floor(th / 60)\r\n    let f = th / 60 - i\r\n    let m = v * (1 - s)\r\n    let n = v * (1 - s * f)\r\n    let k = v * (1 - s * (1 - f))\r\n    let color = new Array()\r\n\r\n    if(!s > 0 && !s < 0) {\r\n      color.push(v, v, v, a)\r\n    } else {\r\n      let r = new Array(v, n, m, m, k, v)\r\n      let g = new Array(k, v, v, n, m, m)\r\n      let b = new Array(m, m, k, v, v, n)\r\n      color.push(r[i], g[i], b[i], a)\r\n    }\r\n\r\n    return color\r\n  }\r\n\r\n}\r\n\r\nexport default new Common()","import Common from \"./Common\"\r\n\r\n export default class MyGL {\r\n   \r\n   constructor(props) {\r\n     this.props = props\r\n     this.init()\r\n   }\r\n\r\n   init() {\r\n     Common.init(this.props.$canvas)\r\n   }\r\n }","<template>\r\n  <div id=\"webgl\">\r\n    <canvas id=\"webgl_canvas\" ref=\"canvas\"></canvas>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport MyGL from \"./js/MyGL\"\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n    }\r\n  },\r\n  mounted() {\r\n    if(!this.MyGL) {\r\n      this.MyGL = new MyGL({\r\n        $canvas: this.$refs.canvas\r\n      })\r\n    }\r\n  },\r\n  methods: {\r\n    \r\n  },\r\n}\r\n</script>\r\n\r\n<style>\r\n  #webgl {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: #fff;\r\n  }\r\n</style>","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./index.vue?vue&type=template&id=30bfafa4&\"\nimport script from \"./index.vue?vue&type=script&lang=js&\"\nexport * from \"./index.vue?vue&type=script&lang=js&\"\nimport style0 from \"./index.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","<template>\n  <div id=\"app\">\n    <MyGL />\n  </div>\n</template>\n\n<script>\nimport MyGL from \"./components/Mywork/index\"\n\nexport default {\n  name: 'App',\n  components: {\n    MyGL,\n  }\n}\n</script>\n\n<style>\n\n</style>\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=dbc9d652&\"\nimport script from \"./App.vue?vue&type=script&lang=js&\"\nexport * from \"./App.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import Vue from 'vue'\nimport App from './App.vue'\n\nVue.config.productionTip = false\n\nnew Vue({\n  render: h => h(App),\n}).$mount('#app')\n"],"sourceRoot":""}